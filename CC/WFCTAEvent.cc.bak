#include <stdlib.h>
#include <iostream>
#include "WFCTAEvent.h"
#include "dumpPack.h"
#include "camera.h"

using namespace std;

//ClassImp(WFCTAEvent);

WFCTAEvent::WFCTAEvent()
{
}

WFCTAEvent::~WFCTAEvent()
{
}

/**********************
 * **find status pack**
 * ********************/
uint8_t WFCTAEvent::StatusPackCheck(uint8_t *begin, int bufsize)
{
    readPos = 0;
    while(readPos<bufsize)
    {
        if( *(begin+readPos+0)==0x12 && *(begin+readPos+1)==0x34 && *(begin+readPos+62)==0xab && *(begin+readPos+63)==0xcd ){
            packSize = readPos+64;
            status_pack_mark = *(begin+readPos+3);//FPGA 1-9 PACK
	    if(status_pack_mark==0){status_pack_mark = 9;}
            return status_pack_mark;
        }

        if( *(begin+readPos+0)==0x12 && *(begin+readPos+1)==0x34 && *(begin+readPos+70)==0xab && *(begin+readPos+71)==0xcd){
            packSize = readPos+72;
	    status_pack_mark = *(begin+readPos+3);
            return status_pack_mark;
        }

        if( *(begin+readPos+0)==0x12 && *(begin+readPos+1)==0x34 && *(begin+readPos+72)==0xab && *(begin+readPos+73)==0xcd){
            packSize = readPos+74;
            status_pack_mark = 85;
            return status_pack_mark;
        }
        readPos++;
    }
    return 0;
}


/**********************
 * **find big package**
 * ********************/
bool WFCTAEvent::bigPackCheck(uint8_t *begin, int bufsize)
{
    int64_t big_pack_len;
    readPos = 0;
    while(readPos<bufsize)
    {
	if(   *(begin+readPos+0)==0xcc && *(begin+readPos+1)==0xcc 
	   && *(begin+readPos+2)==0xdd && *(begin+readPos+3)==0xdd
	   && *(begin+readPos+4)==0xee && *(begin+readPos+5)==0xee
	   && *(begin+readPos+6)==0xff && *(begin+readPos+7)==0xff)
	{
	    head = readPos;
	    break;
	}
        readPos++;
    }

    readPos = 0;
    while(readPos<bufsize)
    {
	if(   *(begin+readPos+0)==0x11 && *(begin+readPos+1)==0x11 
	   && *(begin+readPos+2)==0x22 && *(begin+readPos+3)==0x22  
	   && *(begin+readPos+4)==0x33 && *(begin+readPos+5)==0x33 
	   && *(begin+readPos+6)==0x44 && *(begin+readPos+7)==0x44)
	{
	    tail = readPos+7;
	    break;
	}
	readPos++;
    }

    big_pack_len = tail- head;
    packSize = tail;
    if(big_pack_len>0)
	{
	    //dumpPacket(begin+head,24);printf("%lld ** %lld ** packsize:%lld | ",head,tail,packSize);
	    return true;
	}
    else
	{return false;}
}

/**********************
 * **   find sipms   **
 * ********************/
void WFCTAEvent::Find_SiPMs(uint8_t *begin, int packsize)
{
    short fpga,db;
    short sc,channel,sipm;
    m_sipm_position.clear();
    readPos = 0;
    while(readPos<packsize)
    {
        if(   *(begin+readPos+0)==0xaa && *(begin+readPos+1)==0xaa
           && *(begin+readPos+124)==0xbb && *(begin+readPos+125)==0xbb)
        {
	    fpga = *(begin+readPos+5)&0x0f;
	    db = *(begin+readPos+5)>>4;
	    sc = db*10+fpga;
	    channel = *(begin+readPos+4);
	    SC_Channel2SiPM(sc,channel,&sipm);
	    m_sipm_position.insert(pair<short,int>(sipm,(int)readPos));
        }
        readPos++;
    }
    //dumpPacket(begin,packsize,16);
}

/**********************
 * **  get event ID  **
 * ********************/
uint64_t WFCTAEvent::eventId(uint8_t *begin)
{
    uint64_t evtid = ((uint64_t)begin[head+8]<<24)|
                      ((uint64_t)begin[head+9]<<16)|
                      ((uint64_t)begin[head+10]<<8)|
                      ((uint64_t)begin[head+11]);
    //dumpPacket(begin,24,16);
    printf("event:%llu\n",evtid);
    return evtid;
}

/**********************
 * ** get rabbitTime **
 * ********************/
uint64_t WFCTAEvent::RabbitTime(uint8_t *begin)
{
    uint64_t rab_Time = ((uint64_t)begin[tail-15]<<30)|
                        ((uint64_t)begin[tail-14]<<22)|
                        ((uint64_t)begin[tail-13]<<14)|
                        ((uint64_t)begin[tail-12]<<6)|
                        ((uint64_t)begin[tail-11]>>2&0x3f);
    return rab_Time;
}
/**********************
 * ** get rabbittime **
 * ********************/
uint64_t WFCTAEvent::Rabbittime(uint8_t *begin)
{
    uint64_t rab_time = (((uint64_t)begin[tail-11]&0x03)<<24)|
                        ((uint64_t)begin[tail-10]<<16)|
                        ((uint64_t)begin[tail-9]<<8)|
                        ((uint64_t)begin[tail-8]<<0);
    return rab_time;
}

/****************************
 * **get wave peak position**
 * **************************/
uint8_t WFCTAEvent::GetPeak(uint8_t *begin, short isipm)
{
    m_sipm_position_iter = m_sipm_position.find(isipm);
    uint8_t m_peak = ((uint8_t)begin[m_sipm_position_iter->second+2]*64)|
	     ((uint8_t)begin[m_sipm_position_iter->second+3]>>2);
    //dumpPacket(begin+m_sipm_position_iter->second,128,16);
    return m_peak;
}

/**********************
 * **single threshold**
 * ********************/
uint16_t WFCTAEvent::GetSingle_Thresh(uint8_t *begin, short isipm)
{
    m_sipm_position_iter = m_sipm_position.find(isipm);
    uint16_t m_Single_Threshold = ((uint16_t)begin[m_sipm_position_iter->second+120]<<8)|
			       ((uint16_t)begin[m_sipm_position_iter->second+121]);
    return m_Single_Threshold;
}

/**********************
 * **record threshold**
 * ********************/
uint16_t WFCTAEvent::GetRecord_Thresh(uint8_t *begin, short isipm)
{
    m_sipm_position_iter = m_sipm_position.find(isipm);
    uint16_t m_Record_Threshold = ((uint16_t)begin[m_sipm_position_iter->second+122]<<8)|
                               ((uint16_t)begin[m_sipm_position_iter->second+123]);
    return m_Record_Threshold;
}

/************************
 * **over single marker**
 * **********************/
bool WFCTAEvent::GetOver_Single_Mark(uint8_t *begin, short isipm)
{
    m_sipm_position_iter = m_sipm_position.find(isipm);
    bool m_Over_Single_Mark = begin[m_sipm_position_iter->second+3]&0x2;
    return m_Over_Single_Mark;
}

/************************
 * **over record marker**
 * **********************/
bool WFCTAEvent::GetOver_Record_Mark(uint8_t *begin, short isipm)
{
    m_sipm_position_iter = m_sipm_position.find(isipm);
    bool m_Over_Record_Mark = begin[m_sipm_position_iter->second+3]&0x1;
    return m_Over_Record_Mark;
}

/***********************
 * **   high gain Q   **
 * *********************/
float WFCTAEvent::AdcHigh(uint8_t *begin, short isipm)
{
    m_sipm_position_iter = m_sipm_position.find(isipm);
    m_adc_high = (float)( ((uint64_t)begin[m_sipm_position_iter->second+104]<<24)|
		          ((uint64_t)begin[m_sipm_position_iter->second+105]<<16)|
		          ((uint64_t)begin[m_sipm_position_iter->second+106]<<8)|
		          ((uint64_t)begin[m_sipm_position_iter->second+107]) ) - m_base_high*64.;
    return m_adc_high;
}
/**********************
 * **   low gian Q   **
 * ********************/
float WFCTAEvent::AdcLow(uint8_t *begin, short isipm)
{
    m_sipm_position_iter = m_sipm_position.find(isipm);
    m_adc_low = (float)( ((uint64_t)begin[m_sipm_position_iter->second+108]<<24)|
                         ((uint64_t)begin[m_sipm_position_iter->second+109]<<16)|
                         ((uint64_t)begin[m_sipm_position_iter->second+110]<<8)|
                         ((uint64_t)begin[m_sipm_position_iter->second+111]) ) - m_base_low*64.;
    return m_adc_low;
}
/**********************
 * ** high gain base **
 * ********************/
float WFCTAEvent::BaseHigh(uint8_t *begin, short isipm)
{
    m_sipm_position_iter = m_sipm_position.find(isipm);
    m_base_high = (float)( ((uint64_t)begin[m_sipm_position_iter->second+112]<<24)|
                          ((uint64_t)begin[m_sipm_position_iter->second+113]<<16)|
                          ((uint64_t)begin[m_sipm_position_iter->second+114]<<8)|
                          ((uint64_t)begin[m_sipm_position_iter->second+115]) ) / 256;
    return m_base_high;
}
/***********************
 * **  low gain base  **
 * *********************/
float WFCTAEvent::BaseLow(uint8_t *begin, short isipm)
{
    m_sipm_position_iter = m_sipm_position.find(isipm);
    m_base_low = (float)( ((uint64_t)begin[m_sipm_position_iter->second+116]<<24)|
                         ((uint64_t)begin[m_sipm_position_iter->second+117]<<16)|
                         ((uint64_t)begin[m_sipm_position_iter->second+118]<<8)|
                         ((uint64_t)begin[m_sipm_position_iter->second+119]) ) / 256;
    return m_base_low;
}

/***********************
 * ** H|L gain marker **
 * *********************/
bool WFCTAEvent::Getgain_marker(uint8_t *begin, short isipm)
{
    WFCTAEvent::waveform(begin,isipm);
    bool m_gain_marker = 0;
    for(int i=0;i<29;i++){
	if(pulsehigh[i]>4000){m_gain_marker = 1;}
    }
    return m_gain_marker;
}


/****************************
 * ** get peak in waveform **
 * **************************/
uint8_t WFCTAEvent::Getmypeak(uint8_t *begin, short isipm)
{
    WFCTAEvent::waveform(begin,isipm);
    double sumhighmax = -1000;
    double sumhigh;
    for(int i=0;i<29;i++){
	sumhigh = pulsehigh[i]+pulsehigh[i+1]+pulsehigh[i+2]+pulsehigh[i+3];
        sumhigh /=4.;
	if(sumhighmax<sumhigh) {sumhighmax = sumhigh; m_mypeak = i;}
    }
    return m_mypeak;
}

/*********************************************
 * ** get maximum calculation of four point **
 * *******************************************/
float WFCTAEvent::GetADC_Cut(uint8_t *begin, short isipm)
{
    WFCTAEvent::waveform(begin,isipm);
    double Four_Point_Q = -1000;
    double sum_4;
    for(int i=0;i<29;i++){
        sum_4 = pulsehigh[i]+pulsehigh[i+1]+pulsehigh[i+2]+pulsehigh[i+3];
        if(Four_Point_Q<sum_4) {Four_Point_Q = sum_4;}
    }
    Four_Point_Q -= (4. * m_base_high);
    return Four_Point_Q;

}

/*****************************************************************
 * ** get qhigh/qlow/basehigh/baselow, which calc from waveform **
 * ***************************************************************/
float WFCTAEvent::GetmyImageBaseHigh(uint8_t *begin, short isipm)
{
    WFCTAEvent::Calc_Q_Base(begin,isipm);
    return m_Basehigh;
}

float WFCTAEvent::GetmyImageBaseLow(uint8_t *begin, short isipm)
{   
    WFCTAEvent::Calc_Q_Base(begin,isipm);
    return m_Baselow;
}

float WFCTAEvent::GetmyImageAdcHigh(uint8_t *begin, short isipm)
{
    WFCTAEvent::Calc_Q_Base(begin,isipm);
    return m_Adchigh;
}

float WFCTAEvent::GetmyImageAdcLow(uint8_t *begin, short isipm)
{
    WFCTAEvent::Calc_Q_Base(begin,isipm);
    return m_Adclow;
}

/******************************
 * ** get wave form [public] **
 * ****************************/
void WFCTAEvent::GetWaveForm(uint8_t *begin, short isipm, int *pulseh, int *pulsel)
{
//dumpPacket(begin+m_sipm_position_iter->second+6,54,3);
//dumpPacket(begin+m_sipm_position_iter->second+60,5);
//dumpPacket(begin+m_sipm_position_iter->second+65,39,3);
}




/*************************************
 * ** calc q and base from waveform **
 * ***********************************/
void WFCTAEvent::Calc_Q_Base(uint8_t *begin, short isipm)
{
    WFCTAEvent::Getmypeak(begin,isipm);
    m_Basehigh = 0;
    m_Baselow = 0;
    m_Adchigh = 0;
    m_Adclow = 0;
    if(m_mypeak<8)
    {
        for(int i=31;i>21;i--)  { m_Basehigh += pulsehigh[i]; m_Baselow += pulselow[i];}
        m_Basehigh = m_Basehigh/10.;
        m_Baselow = m_Baselow/10.;
	for(int i=0;i<m_mypeak+9;i++) { m_Adchigh += pulsehigh[i]-m_Basehigh; m_Adclow += pulselow[i]-m_Baselow;}
    }
    else if(m_mypeak>22)
    {
        for(int i=0;i<10;i++)  { m_Basehigh += pulsehigh[i]; m_Baselow += pulselow[i];}
        m_Basehigh = m_Basehigh/10.;
        m_Baselow = m_Baselow/10.;
        for(int i=m_mypeak-6;i<31;i++) { m_Adchigh += pulsehigh[i]-m_Basehigh; m_Adclow += pulselow[i]-m_Baselow;}
    }
    else
    {
        for(int i=0;i<5;i++)  { m_Basehigh += pulsehigh[i]; m_Baselow += pulselow[i];}
        for(int i=31;i>26;i--)  { m_Basehigh += pulsehigh[i]; m_Baselow += pulselow[i];}
        m_Basehigh = m_Basehigh/10.;
        m_Baselow = m_Baselow/10.;
        for(int i=m_mypeak-6;i<m_mypeak+9;i++) { m_Adchigh += pulsehigh[i]-m_Basehigh; m_Adclow += pulselow[i]-m_Baselow;}
    }
}

/******************************
 * ** get wave form [privat] **
 * ****************************/
void WFCTAEvent::waveform(uint8_t *begin, short isipm)
{   
    m_sipm_position_iter = m_sipm_position.find(isipm);
    int waveStart1 = 6;
    int waveEnd1 = 58;
    int waveStart2 = 65;
    int waveEnd2 = 104;
    int middleWave = 60;
    int ipoint = 0;
    
    for(int i=waveStart1; i<waveEnd1; i = i+3)
    {   
        pulsehigh[ipoint] = ((int)begin[m_sipm_position_iter->second+i]<<4)|((int)begin[m_sipm_position_iter->second+i+1]>>4);
        pulselow[ipoint] = (((int)begin[m_sipm_position_iter->second+i+1]&0x0f)<<8)|((int)begin[m_sipm_position_iter->second+i+2]);
        ipoint++;
    }   
        pulsehigh[ipoint] = ((int)begin[m_sipm_position_iter->second+middleWave]<<4)|((int)begin[m_sipm_position_iter->second+middleWave+1]>>4);
        pulselow[ipoint] = (((int)begin[m_sipm_position_iter->second+middleWave+1]&0x0f)<<8)|((int)begin[m_sipm_position_iter->second+middleWave+4]);
        ipoint++;
    for(int i=waveStart2; i<waveEnd2; i = i+3)
    {   
        pulsehigh[ipoint] = ((int)begin[m_sipm_position_iter->second+i]<<4)|((int)begin[m_sipm_position_iter->second+i+1]>>4);
        pulselow[ipoint] = (((int)begin[m_sipm_position_iter->second+i+1]&0x0f)<<8)|((int)begin[m_sipm_position_iter->second+i+2]);
        ipoint++;
    }
}







